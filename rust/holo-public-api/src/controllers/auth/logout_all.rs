use actix_web::{get, web, HttpRequest, HttpResponse, Responder};
use mongodb::Database;
use serde_json::json;
use utoipa::OpenApi;

use crate::providers::{database::schemas, error_response::ErrorResponse, permissions::get_claims_from_req};

#[derive(OpenApi)]
#[openapi(
    paths(logout_all)
)]
pub struct OpenApiSpec;

#[utoipa::path(
    get,
    path = "/protected/v1/auth/logout-all",
    tag = "Auth",
    summary = "Logout all sessions",
    description = "Logout all sessions by invalidating all refresh tokens generated by the user",
    security(
        ("Bearer" = [])
    ),
    responses(
        (status = 200)
    )
)]
#[get("/v1/auth/logout-all")]
pub async fn logout_all(
    req: HttpRequest,
    db: web::Data<Database>
) -> impl Responder {
    let claims = match get_claims_from_req(req) {
        Some(claims) => claims,
        None => {
            return HttpResponse::Unauthorized().json(ErrorResponse {
                message: "Unauthorized".to_string(),
            });
        }
    };
    let user_id = claims.sub.clone();
    let user_id = bson::oid::ObjectId::parse_str(&user_id).unwrap(); 
    match db.collection::<schemas::user::User>(
        schemas::user::USER_COLLECTION_NAME
    ).update_one(
        bson::doc!{ "_id": user_id },
        bson::doc!{ "$inc": { "refresh_token_version": 1 } },
        None
    ).await {
        Ok(_) => HttpResponse::Ok().json(json!({})),
        Err(e) => {
            tracing::error!("Error updating user: {}", e);
            HttpResponse::InternalServerError().json(json!({}))
        }
    }
}